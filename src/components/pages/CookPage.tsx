import {
	Badge,
	Box,
	Button,
	Card,
	CardBody,
	Container,
	Flex,
	HStack,
	Heading,
	Icon,
	IconButton,
	Progress,
	Spinner,
	Switch,
	Text,
	VStack,
	useBreakpointValue,
	useColorModeValue,
	useToast,
} from "@chakra-ui/react";
import { AnimatePresence, motion } from "framer-motion";
import { useAtom, useAtomValue, useSetAtom } from "jotai";
import { useCallback, useEffect, useRef, useState } from "react";
import {
	FaArrowLeft,
	FaArrowRight,
	FaCheck,
	FaMicrophone,
	FaMicrophoneSlash,
	FaPause,
	FaUtensils,
	FaVolumeOff,
	FaVolumeUp,
} from "react-icons/fa";
import { HiSparkles } from "react-icons/hi2";
import { useNavigate, useParams } from "react-router";

import Header from "@/components/organisms/Header";
import { postCookHistoryAtom } from "@/lib/atom/CookAtom";
import {
	currentRecipeAtom,
	getProcessesAtom,
	getRecipeByIdAtom,
	processesAtom,
} from "@/lib/atom/RecipeAtom";
import { type ChatVoice, generateVoice } from "@/lib/domain/VoiceQuery";
import { useCookWebSocket } from "@/lib/hook/useCookWebSocket";
import { useVoiceRecorder } from "@/lib/hook/useVoiceRecorder";

// Motion components
const MotionBox = motion(Box);
const MotionCard = motion(Card);

function webSocketStatus(status: string) {
	switch (status) {
		case "Connecting":
			return {
				icon: <Icon as={FaMicrophone} boxSize={4} color="orange.500" />,
				text: "Êé•Á∂ö‰∏≠...",
				color: "orange.500",
			};
		case "Open":
			return {
				icon: <Icon as={FaMicrophone} boxSize={4} color="green.500" />,
				text: "„Ç™„É≥„É©„Ç§„É≥",
				color: "green.500",
			};
		case "Closing":
			return {
				icon: <Icon as={FaMicrophone} boxSize={4} color="red.500" />,
				text: "ÂàáÊñ≠‰∏≠...",
				color: "red.500",
			};
		case "Closed":
			return {
				icon: <Icon as={FaMicrophone} boxSize={4} color="gray.500" />,
				text: "„Ç™„Éï„É©„Ç§„É≥",
				color: "gray.500",
			};
		default:
			return {
				icon: <Icon as={FaMicrophone} boxSize={4} color="gray.500" />,
				text: "‰∏çÊòé",
				color: "gray.500",
			};
	}
}

export default function CookPage() {
	const { recipeId } = useParams<{ recipeId: string }>();
	const navigate = useNavigate();
	const [currentStep, setCurrentStep] = useState(0);
	const [currentVoice, setCurrentVoice] = useState<ChatVoice | null>(null);
	const [isVoiceLoading, setIsVoiceLoading] = useState(false);
	const [isVoicePlaying, setIsVoicePlaying] = useState(false);
	const [autoPlayEnabled, setAutoPlayEnabled] = useState(false);
	const [autoPlayTimeout, setAutoPlayTimeout] = useState<number | null>(null);
	const [lastVoiceCommand, setLastVoiceCommand] = useState<string | null>(null);
	const toast = useToast();
	const isMobile = useBreakpointValue({ base: true, md: false });

	// Refs for cleanup
	const currentVoiceRef = useRef<ChatVoice | null>(null);
	const autoPlayTimeoutRef = useRef<number | null>(null);

	// Update refs when state changes
	useEffect(() => {
		currentVoiceRef.current = currentVoice;
	}, [currentVoice]);

	useEffect(() => {
		autoPlayTimeoutRef.current = autoPlayTimeout;
	}, [autoPlayTimeout]);

	// Atoms
	const [, getProcesses] = useAtom(getProcessesAtom);
	const [, getCurrentRecipe] = useAtom(getRecipeByIdAtom);
	const processes = useAtomValue(processesAtom);
	const currentRecipe = useAtomValue(currentRecipeAtom);
	const postCookHistory = useSetAtom(postCookHistoryAtom);

	// Color values
	const bgGradient = useColorModeValue(
		"linear(to-br, orange.50, pink.50, purple.50)",
		"linear(to-br, gray.900, purple.900, pink.900)",
	);
	const cardBg = useColorModeValue("white", "gray.800");
	const textColor = useColorModeValue("gray.800", "white");
	const mutedColor = useColorModeValue("gray.600", "gray.400");
	const primaryColor = useColorModeValue("purple.500", "purple.300");
	const borderColor = useColorModeValue("gray.200", "gray.600");

	// Load data on mount
	useEffect(() => {
		if (recipeId) {
			getCurrentRecipe(Number(recipeId));
			getProcesses(Number(recipeId));
		}
	}, [recipeId, getCurrentRecipe, getProcesses]);

	// Sort processes by process number
	const sortedProcesses = processes.sort(
		(a, b) => a.processNumber - b.processNumber,
	);
	const totalSteps = sortedProcesses.length;
	const progress = totalSteps > 0 ? ((currentStep + 1) / totalSteps) * 100 : 0;
	const currentProcess = sortedProcesses[currentStep];

	// „Åì„Åì„Åã„ÇâWebsocketÈÄö‰ø°„ÅÆË®≠ÂÆö
	const shouldConnect = true; // WebSocketÊé•Á∂ö„ÇíÊúâÂäπÂåñ

	const { connectionStatus, disconnect, sendMessage } = useCookWebSocket({
		onMessage: (message) => {
			handleWebSocketMessage(message.data);
		},
		shouldConnect: shouldConnect,
	});

	// Èü≥Â£∞Èå≤Èü≥Ê©üËÉΩ
	const voiceRecorder = useVoiceRecorder({
		onDataAvailable: (audioData) => {
			// Èü≥Â£∞„Éá„Éº„Çø„ÇíWebSocket„ÅßÈÄÅ‰ø°
			if (connectionStatus === "Open" && sendMessage) {
				try {
					// „Éê„Ç§„Éä„É™„Éá„Éº„Çø„Å®„Åó„Å¶Áõ¥Êé•ÈÄÅ‰ø°
					sendMessage(audioData);
					console.log(
						"Èü≥Â£∞„Éá„Éº„ÇøÈÄÅ‰ø°:",
						audioData.byteLength,
						"bytes (PCM 16bit 16kHz Mono)",
					);
				} catch (error) {
					console.error("Èü≥Â£∞„Éá„Éº„ÇøÈÄÅ‰ø°„Ç®„É©„Éº:", error);
				}
			}
		},
		silenceThreshold: 30, // Èü≥Â£∞Ê§úÂá∫„ÅÆÈñæÂÄ§
		silenceTimeout: 1000, // 1ÁßíÈñìÁÑ°Èü≥„ÅßÈå≤Èü≥ÂÅúÊ≠¢
		minRecordingTime: 500, // ÊúÄÂ∞èÈå≤Èü≥ÊôÇÈñì500ms
	});

	const statusInfo = webSocketStatus(connectionStatus);

	const handleNext = () => {
		console.log("ÁèæÂú®„ÅÆÁï™Âè∑:", currentStep, "Ê¨°„Å∏ÁßªÂãïË©¶Ë°å");
		if (currentStep < totalSteps - 1) {
			setCurrentStep(currentStep + 1);
		}
	};

	const handlePrevious = () => {
		console.log("ÁèæÂú®„ÅÆÁï™Âè∑:", currentStep, "Ââç„Å∏ÁßªÂãïË©¶Ë°å");
		if (currentStep > 0) {
			setCurrentStep(currentStep - 1);
		}
	};

	const handleStepJump = (stepIndex: number) => {
		setCurrentStep(stepIndex);
		// Èü≥Â£∞„ÇíÂÅúÊ≠¢
		if (currentVoice) {
			currentVoice.stop();
			setIsVoicePlaying(false);
		}
	};

	const handleComplete = () => {
		// Èü≥Â£∞Èå≤Èü≥„ÇíÂÅúÊ≠¢
		if (voiceRecorder.isListening) {
			voiceRecorder.stopListening();
		}

		// Èü≥Â£∞„ÇíÂÅúÊ≠¢
		if (currentVoice) {
			currentVoice.stop();
			setCurrentVoice(null);
			setIsVoicePlaying(false);
		}
		// „Çø„Ç§„Éû„Éº„Çí„ÇØ„É™„Ç¢
		if (autoPlayTimeout) {
			clearTimeout(autoPlayTimeout);
			setAutoPlayTimeout(null);
		}

		toast({
			title: "„ÅäÁñ≤„ÇåÊßò„Åß„Åó„ÅüÔºÅ",
			description: "ÊñôÁêÜ„ÅåÂÆåÊàê„Åó„Åæ„Åó„Åü„ÄÇÁæéÂë≥„Åó„Åè„ÅäÂè¨„Åó‰∏ä„Åå„Çä„Åè„Å†„Åï„ÅÑÔºÅ",
			status: "success",
			duration: 3000,
			isClosable: true,
		});

		// „ÇØ„ÉÉ„ÇØÂ±•Ê≠¥„Çí‰øùÂ≠ò
		postCookHistory(Number(recipeId));

		// WebSocketÊé•Á∂ö„ÇíÂàáÊñ≠
		disconnect();

		// „É¨„Ç∑„Éî„Éö„Éº„Ç∏„Å´Êàª„Çã
		navigate(`/home/recipe/${recipeId}`);
	};

	const handleBackToRecipe = () => {
		// Èü≥Â£∞Èå≤Èü≥„ÇíÂÅúÊ≠¢
		if (voiceRecorder.isListening) {
			voiceRecorder.stopListening();
		}

		// Èü≥Â£∞„ÇíÂÅúÊ≠¢
		if (currentVoice) {
			currentVoice.stop();
			setCurrentVoice(null);
			setIsVoicePlaying(false);
		}
		// „Çø„Ç§„Éû„Éº„Çí„ÇØ„É™„Ç¢
		if (autoPlayTimeout) {
			clearTimeout(autoPlayTimeout);
			setAutoPlayTimeout(null);
		}

		navigate(`/home/recipe/${recipeId}`);
	};
	// Ëá™ÂãïÈü≥Â£∞ÂÜçÁîüÊ©üËÉΩ
	const autoPlayVoice = useCallback(
		async (instruction: string) => {
			if (!autoPlayEnabled) return;

			try {
				setIsVoiceLoading(true);

				// Êó¢Â≠ò„ÅÆÈü≥Â£∞„ÇíÂÅúÊ≠¢
				if (currentVoice) {
					currentVoice.stop();
					setIsVoicePlaying(false);
				}

				const voice = await generateVoice("cooking-assistant", instruction);
				setCurrentVoice(voice);

				setIsVoicePlaying(true);
				await voice.play();
				setIsVoicePlaying(false);
			} catch (error) {
				// AbortError„ÅØÊ≠£Â∏∏„Å™‰∏≠Êñ≠„Å®„Åó„Å¶Êâ±„ÅÜ
				if (error instanceof Error && error.name === "AbortError") {
					console.log("Èü≥Â£∞ÂÜçÁîü„Åå‰∏≠Êñ≠„Åï„Çå„Åæ„Åó„ÅüÔºàÊ≠£Â∏∏Ôºâ");
					setIsVoicePlaying(false);
				} else {
					console.error("Ëá™ÂãïÈü≥Â£∞ÂÜçÁîü„Ç®„É©„Éº:", error);
				}
			} finally {
				setIsVoiceLoading(false);
			}
		},
		[autoPlayEnabled], // currentVoice„Çí‰æùÂ≠òÈÖçÂàó„Åã„ÇâÈô§Â§ñ
	);

	// Èü≥Â£∞ÁîüÊàê„ÉªÂÜçÁîü„ÅÆ„Éè„É≥„Éâ„É©„Éº
	const handleVoicePlay = async () => {
		if (!currentProcess) return;

		try {
			setIsVoiceLoading(true);

			// Êó¢Â≠ò„ÅÆÈü≥Â£∞„ÇíÂÅúÊ≠¢
			if (currentVoice) {
				currentVoice.stop();
				setIsVoicePlaying(false);
			}

			const voice = await generateVoice(
				"cooking-assistant",
				currentProcess.process,
			);
			setCurrentVoice(voice);

			setIsVoicePlaying(true);
			await voice.play();
			setIsVoicePlaying(false);
		} catch (error) {
			// AbortError„ÅØÊ≠£Â∏∏„Å™‰∏≠Êñ≠„Å®„Åó„Å¶Êâ±„ÅÜ
			if (error instanceof Error && error.name === "AbortError") {
				console.log("Èü≥Â£∞ÂÜçÁîü„Åå‰∏≠Êñ≠„Åï„Çå„Åæ„Åó„ÅüÔºàÊ≠£Â∏∏Ôºâ");
				setIsVoicePlaying(false);
			} else {
				console.error("Èü≥Â£∞ÁîüÊàê„ÉªÂÜçÁîü„Ç®„É©„Éº:", error);
				toast({
					title: "Èü≥Â£∞„ÅÆÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü",
					description: "„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ",
					status: "error",
					duration: 3000,
					isClosable: true,
				});
			}
		} finally {
			setIsVoiceLoading(false);
		}
	};

	const handleVoiceStop = () => {
		if (currentVoice) {
			currentVoice.stop();
			setIsVoicePlaying(false);
		}
	};

	// WebSocket„É°„ÉÉ„Çª„Éº„Ç∏Âá¶ÁêÜÈñ¢Êï∞
	const handleWebSocketMessage = useCallback(
		(data: string) => {
			try {
				const message = JSON.parse(data);
				console.log("WebSocket„É°„ÉÉ„Çª„Éº„Ç∏Âèó‰ø°:", message);

				// JSON„Çπ„Ç≠„Éº„Éû„Å´Âü∫„Å•„ÅèÂá¶ÁêÜ
				if (message && typeof message === "object" && "status" in message) {
					const { status } = message;

					switch (status) {
						case "next":
							console.log("Èü≥Â£∞„Ç≥„Éû„É≥„Éâ: Ê¨°„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó„Å∏");
							setLastVoiceCommand("Ê¨°„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó");
							// currentStep„ÇíÁõ¥Êé•Êõ¥Êñ∞
							setCurrentStep((prev) => {
								console.log(
									"ÁèæÂú®„ÅÆÁï™Âè∑:",
									prev,
									"‚Üí",
									Math.min(prev + 1, totalSteps - 1),
								);
								return prev < totalSteps - 1 ? prev + 1 : prev;
							});
							toast({
								title: "üé§ Èü≥Â£∞„Ç≥„Éû„É≥„ÉâÂÆüË°å",
								description: "Ê¨°„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó„Å´ÈÄ≤„Åø„Åæ„Åô",
								status: "info",
								duration: 2000,
								isClosable: true,
							});
							break;

						case "previous":
							console.log("Èü≥Â£∞„Ç≥„Éû„É≥„Éâ: Ââç„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó„Å∏");
							setLastVoiceCommand("Ââç„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó");
							// currentStep„ÇíÁõ¥Êé•Êõ¥Êñ∞
							setCurrentStep((prev) => {
								console.log("ÁèæÂú®„ÅÆÁï™Âè∑:", prev, "‚Üí", Math.max(prev - 1, 0));
								return prev > 0 ? prev - 1 : prev;
							});
							toast({
								title: "üé§ Èü≥Â£∞„Ç≥„Éû„É≥„ÉâÂÆüË°å",
								description: "Ââç„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó„Å´Êàª„Çä„Åæ„Åô",
								status: "info",
								duration: 2000,
								isClosable: true,
							});
							break;

						case "play":
							console.log("Èü≥Â£∞„Ç≥„Éû„É≥„Éâ: Èü≥Â£∞ÂÜçÁîü");
							setLastVoiceCommand("Èü≥Â£∞ÂÜçÁîü");
							handleVoicePlay();
							toast({
								title: "üé§ Èü≥Â£∞„Ç≥„Éû„É≥„ÉâÂÆüË°å",
								description: "ÊâãÈ†Ü„ÇíÈü≥Â£∞„ÅßÂÜçÁîü„Åó„Åæ„Åô",
								status: "info",
								duration: 2000,
								isClosable: true,
							});
							break;

						case "None":
							console.log("Èü≥Â£∞„Ç≥„Éû„É≥„Éâ: „Ç¢„ÇØ„Ç∑„Éß„É≥„Å™„Åó");
							setLastVoiceCommand("Ë™çË≠ò„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü");
							break;

						default:
							console.warn("Êú™Áü•„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ:", status);
							break;
					}
				} else {
					console.warn("‰∏çÊ≠£„Å™„É°„ÉÉ„Çª„Éº„Ç∏ÂΩ¢Âºè:", message);
				}
			} catch (error) {
				console.error("WebSocket„É°„ÉÉ„Çª„Éº„Ç∏ÂàÜÊûê„Ç®„É©„Éº:", error);
			}

			// 3ÁßíÂæå„Å´„Ç≥„Éû„É≥„ÉâË°®Á§∫„Çí„ÇØ„É™„Ç¢
			setTimeout(() => {
				setLastVoiceCommand(null);
			}, 3000);
		},
		[totalSteps, handleVoicePlay, toast],
	);
	// „Çπ„ÉÜ„ÉÉ„ÉóÂ§âÊõ¥ÊôÇ„Å´Èü≥Â£∞„ÇíÂÅúÊ≠¢„Åó„ÄÅËá™ÂãïÂÜçÁîü„Çí„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó
	useEffect(() => {
		let isCancelled = false;

		// Êó¢Â≠ò„ÅÆÈü≥Â£∞„Å®„Çø„Ç§„Éû„Éº„ÇíÂÅúÊ≠¢„Éª„ÇØ„É™„Ç¢
		if (currentVoice) {
			currentVoice.stop();
			setIsVoicePlaying(false);
		}
		if (autoPlayTimeout) {
			clearTimeout(autoPlayTimeout);
			setAutoPlayTimeout(null);
		}

		// Êñ∞„Åó„ÅÑ„Çπ„ÉÜ„ÉÉ„Éó„ÅßËá™ÂãïÂÜçÁîü„Çí„Çª„ÉÉ„Éà„Ç¢„ÉÉ„ÉóÔºà2ÁßíÂæå„Å´ÂÜçÁîüÔºâ
		if (autoPlayEnabled && sortedProcesses[currentStep] && !isCancelled) {
			const timeout = window.setTimeout(() => {
				// „Çø„Ç§„É†„Ç¢„Ç¶„ÉàÂÆüË°åÊôÇ„Å´„Ç≠„É£„É≥„Çª„É´„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
				if (!isCancelled) {
					autoPlayVoice(sortedProcesses[currentStep].process);
				}
			}, 2000); // 2Áßí„ÅÆÈÅÖÂª∂„ÅßËá™ÂãïÂÜçÁîü
			setAutoPlayTimeout(timeout);
		}

		// „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÈñ¢Êï∞
		return () => {
			isCancelled = true;
			if (autoPlayTimeout) {
				clearTimeout(autoPlayTimeout);
			}
		};
	}, [currentStep, autoPlayEnabled, sortedProcesses, autoPlayVoice]); // currentVoice, autoPlayTimeout„Çí‰æùÂ≠òÈÖçÂàó„Åã„ÇâÈô§Â§ñ	// „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÁµÇ‰∫ÜÊôÇ„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
	useEffect(() => {
		return () => {
			if (currentVoiceRef.current) {
				currentVoiceRef.current.stop();
			}
			if (autoPlayTimeoutRef.current) {
				clearTimeout(autoPlayTimeoutRef.current);
			}
		};
	}, []); // Á©∫„ÅÆ‰æùÂ≠òÈÖçÂàó„Åß„Éû„Ç¶„É≥„ÉàÊôÇ„ÅÆ„ÅøÂÆüË°å

	// Loading state
	if (!currentRecipe || sortedProcesses.length === 0) {
		return (
			<Box minH="100vh" bgGradient={bgGradient}>
				<Header />
				<Container maxW="4xl" py={8}>
					<VStack spacing={8}>
						<Spinner size="xl" color="purple.500" />
						<Text color={textColor}>ÊñôÁêÜÊâãÈ†Ü„ÇíË™≠„ÅøËæº„Åø‰∏≠...</Text>
					</VStack>
				</Container>
			</Box>
		);
	}

	if (!currentProcess) {
		return (
			<Box minH="100vh" bgGradient={bgGradient}>
				<Header />
				<Container maxW="4xl" py={8}>
					<VStack spacing={8}>
						<Text color={textColor}>ÊñôÁêÜÊâãÈ†Ü„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü</Text>
						<Button onClick={handleBackToRecipe}>„É¨„Ç∑„Éî„Å´Êàª„Çã</Button>
					</VStack>
				</Container>
			</Box>
		);
	}

	return (
		<Box minH="100vh" bgGradient={bgGradient}>
			<Header />

			{/* Header section */}
			<Box
				bg={cardBg}
				borderBottom="1px"
				borderColor={borderColor}
				px={6}
				py={4}
			>
				<Container maxW="4xl">
					{isMobile ? (
						<Box>
							<Button
								leftIcon={<FaArrowLeft />}
								onClick={handleBackToRecipe}
								variant="ghost"
								colorScheme="purple"
							>
								„É¨„Ç∑„Éî„Å´Êàª„Çã
							</Button>
							<HStack spacing={4} justify="space-between" mt={2}>
								<Icon as={FaUtensils} color={primaryColor} boxSize={6} />
								<Text fontSize="lg" fontWeight="bold" color={textColor}>
									{currentRecipe.recipeName}
								</Text>
								{statusInfo.icon}
							</HStack>
							<HStack spacing={2} mt={5}>
								<Icon
									as={autoPlayEnabled ? FaVolumeUp : FaVolumeOff}
									color={autoPlayEnabled ? primaryColor : mutedColor}
									boxSize={6}
								/>
								<Switch
									isChecked={autoPlayEnabled}
									onChange={(e) => setAutoPlayEnabled(e.target.checked)}
									colorScheme="purple"
									size="md"
								/>
								<Text fontSize="xl" color={mutedColor}>
									Ëá™ÂãïÈü≥Â£∞
								</Text>
							</HStack>
						</Box>
					) : (
						<HStack spacing={4} justify="space-between">
							<HStack spacing={4}>
								<Icon as={FaUtensils} color={primaryColor} boxSize={6} />
								<VStack align="start" spacing={0}>
									<Text fontSize="lg" fontWeight="bold" color={textColor}>
										{currentRecipe.recipeName}
									</Text>
									<Text fontSize="sm" color={mutedColor}>
										ÊñôÁêÜÂ∑•Á®ã„Ç¨„Ç§„Éâ
									</Text>
								</VStack>
							</HStack>{" "}
							{/* WebSocket status */}
							<HStack spacing={1}>
								{statusInfo.icon}
								<Text
									fontSize="sm"
									color={statusInfo.color}
									fontWeight="medium"
								>
									{statusInfo.text}
								</Text>
							</HStack>
							{/* ÊúÄÂæå„ÅÆÈü≥Â£∞„Ç≥„Éû„É≥„ÉâË°®Á§∫ */}
							{lastVoiceCommand && (
								<HStack spacing={2} bg="blue.50" px={3} py={1} rounded="md">
									<Text fontSize="xs" color="blue.600" fontWeight="bold">
										üé§ {lastVoiceCommand}
									</Text>
								</HStack>
							)}
							{/* Ëá™ÂãïÂÜçÁîü„Ç≥„É≥„Éà„É≠„Éº„É´ */}
							<HStack spacing={2}>
								<Icon
									as={autoPlayEnabled ? FaVolumeUp : FaVolumeOff}
									color={autoPlayEnabled ? primaryColor : mutedColor}
									boxSize={4}
								/>
								<Switch
									isChecked={autoPlayEnabled}
									onChange={(e) => setAutoPlayEnabled(e.target.checked)}
									colorScheme="purple"
									size="sm"
								/>
								<Text fontSize="xs" color={mutedColor}>
									Ëá™ÂãïÈü≥Â£∞
								</Text>
							</HStack>
							{/* Back button */}
							<Button
								leftIcon={<FaArrowLeft />}
								onClick={handleBackToRecipe}
								variant="ghost"
								colorScheme="purple"
							>
								„É¨„Ç∑„Éî„Å´Êàª„Çã
							</Button>
						</HStack>
					)}
				</Container>
			</Box>

			{/* Progress section */}
			<Box
				bg={cardBg}
				borderBottom="1px"
				borderColor={borderColor}
				px={6}
				pt={4}
			>
				<Container maxW="4xl">
					<VStack spacing={3}>
						<HStack justify="space-between" w="100%">
							<Text fontSize="sm" color={mutedColor}>
								„Çπ„ÉÜ„ÉÉ„Éó {currentStep + 1} / {totalSteps}
							</Text>
							<Badge colorScheme="purple" variant="subtle">
								{Math.round(progress)}% ÂÆå‰∫Ü
							</Badge>
						</HStack>
						<Progress
							value={progress}
							colorScheme="purple"
							w="100%"
							rounded="full"
							h={2}
						/>
						{/* Step navigation dots */}
						<HStack spacing={2} overflowX="auto" maxW="100%" py={2}>
							{sortedProcesses.map((_, index) => (
								<IconButton
									key={index}
									aria-label={`„Çπ„ÉÜ„ÉÉ„Éó ${index + 1}`}
									size="sm"
									variant={index === currentStep ? "solid" : "outline"}
									colorScheme="purple"
									icon={<Text fontSize="xs">{index + 1}</Text>}
									onClick={() => handleStepJump(index)}
									minW="32px"
								/>
							))}
						</HStack>
					</VStack>
				</Container>
			</Box>

			{/* Main content area */}
			<Container maxW="4xl" py={4}>
				<Flex direction="column" justify="center">
					<AnimatePresence mode="wait">
						<MotionCard
							key={currentStep}
							bg={cardBg}
							borderColor={borderColor}
							borderWidth={1}
							maxW="800px"
							mx="auto"
							w="100%"
							initial={{ opacity: 0, x: 50 }}
							animate={{ opacity: 1, x: 0 }}
							exit={{ opacity: 0, x: -50 }}
							transition={{ duration: 0.3 }}
						>
							<CardBody p={8}>
								<VStack spacing={6} textAlign="center">
									{/* Step header */}
									<VStack spacing={2}>
										<HStack spacing={3}>
											<Icon as={HiSparkles} color={primaryColor} boxSize={6} />
											<Heading size="lg" color={textColor}>
												„Çπ„ÉÜ„ÉÉ„Éó {currentProcess.processNumber}
											</Heading>
										</HStack>
									</VStack>

									{/* Step instruction */}
									<MotionBox
										initial={{ scale: 0.95 }}
										animate={{ scale: 1 }}
										transition={{ duration: 0.2, delay: 0.1 }}
									>
										<Text
											fontSize="xl"
											lineHeight="1.8"
											color={textColor}
											whiteSpace="pre-wrap"
											textAlign="left"
											bg={useColorModeValue("gray.50", "gray.700")}
											p={6}
											rounded="xl"
											border="2px"
											borderColor={borderColor}
										>
											{currentProcess.process}
										</Text>
									</MotionBox>
									{/* Voice control buttons */}
									<HStack spacing={4}>
										<Button
											leftIcon={
												isVoiceLoading ? (
													<Spinner size="sm" />
												) : isVoicePlaying ? (
													<Icon as={FaPause} />
												) : (
													<Icon as={FaVolumeUp} />
												)
											}
											onClick={
												isVoicePlaying ? handleVoiceStop : handleVoicePlay
											}
											colorScheme="blue"
											variant="outline"
											isLoading={isVoiceLoading}
											loadingText="ÁîüÊàê‰∏≠"
											size="lg"
										>
											{isVoicePlaying ? "ÂÅúÊ≠¢" : "Èü≥Â£∞„ÅßËÅû„Åè"}
										</Button>

										{/* Èü≥Â£∞Èå≤Èü≥„Éú„Çø„É≥ */}
										<Button
											leftIcon={
												<Icon
													as={
														voiceRecorder.isListening
															? FaMicrophone
															: FaMicrophoneSlash
													}
													color={
														voiceRecorder.isListening ? "red.500" : "gray.500"
													}
												/>
											}
											onClick={
												voiceRecorder.isListening
													? voiceRecorder.stopListening
													: voiceRecorder.startListening
											}
											colorScheme={voiceRecorder.isListening ? "red" : "gray"}
											variant={voiceRecorder.isListening ? "solid" : "outline"}
											size="lg"
											isDisabled={connectionStatus !== "Open"}
										>
											{voiceRecorder.isListening ? "Èü≥Â£∞ÂÅúÊ≠¢" : "Èü≥Â£∞ÈñãÂßã"}
										</Button>
									</HStack>

									{/* Èü≥Â£∞„É¨„Éô„É´Ë°®Á§∫ */}
									{voiceRecorder.isListening && (
										<VStack spacing={2}>
											<Text fontSize="sm" color={mutedColor}>
												Èü≥Èáè„É¨„Éô„É´: {Math.round(voiceRecorder.volume)}
											</Text>
											<Progress
												value={(voiceRecorder.volume / 100) * 100}
												colorScheme={voiceRecorder.isRecording ? "red" : "gray"}
												size="sm"
												w="200px"
											/>
											{voiceRecorder.isRecording && (
												<Text fontSize="xs" color="red.500" fontWeight="bold">
													üî¥ Èå≤Èü≥‰∏≠
												</Text>
											)}
										</VStack>
									)}

									{/* „Ç®„É©„ÉºË°®Á§∫ */}
									{voiceRecorder.error && (
										<Text fontSize="sm" color="red.500">
											„Ç®„É©„Éº: {voiceRecorder.error}
										</Text>
									)}
								</VStack>
							</CardBody>
						</MotionCard>
					</AnimatePresence>
				</Flex>
			</Container>

			{/* Navigation buttons */}
			<Box
				position="fixed"
				bottom={0}
				left={0}
				right={0}
				bg={cardBg}
				borderTop="1px"
				borderColor={borderColor}
				p={4}
			>
				{isMobile ? (
					<Box>
						<HStack justify="space-between">
							<IconButton
								aria-label="Ââç„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó"
								icon={<FaArrowLeft />}
								onClick={handlePrevious}
								isDisabled={currentStep === 0}
								variant="ghost"
								colorScheme="purple"
								size="lg"
							/>
							<VStack spacing={1}>
								<Text fontSize="sm" color={mutedColor}>
									{currentStep === totalSteps - 1
										? "ÊñôÁêÜÂÆå‰∫Ü"
										: "„Çø„ÉÉ„Éó„Åó„Å¶Ê¨°„Å∏"}
								</Text>
								<Text fontSize="xs" color={mutedColor}>
									{currentStep + 1} / {totalSteps}
								</Text>
							</VStack>
							{currentStep === totalSteps - 1 ? (
								<IconButton
									aria-label="ÂÆå‰∫Ü„ÉªÁµÇ‰∫Ü"
									icon={<FaCheck />}
									onClick={handleComplete}
									colorScheme="green"
									size="lg"
								/>
							) : (
								<IconButton
									aria-label="Ê¨°„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó"
									icon={<FaArrowRight />}
									onClick={handleNext}
									colorScheme="purple"
									size="lg"
								/>
							)}
						</HStack>
					</Box>
				) : (
					<Container maxW="4xl">
						<HStack justify="space-between">
							<Button
								leftIcon={<FaArrowLeft />}
								onClick={handlePrevious}
								isDisabled={currentStep === 0}
								variant="ghost"
								colorScheme="purple"
								size="lg"
							>
								Ââç„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó
							</Button>

							<VStack spacing={1}>
								<Text fontSize="sm" color={mutedColor}>
									{currentStep === totalSteps - 1
										? "ÊñôÁêÜÂÆå‰∫Ü"
										: "„Çø„ÉÉ„Éó„Åó„Å¶Ê¨°„Å∏"}
								</Text>
								<Text fontSize="xs" color={mutedColor}>
									{currentStep + 1} / {totalSteps}
								</Text>
							</VStack>

							{currentStep === totalSteps - 1 ? (
								<Button
									rightIcon={<FaCheck />}
									onClick={handleComplete}
									colorScheme="green"
									size="lg"
								>
									ÂÆå‰∫Ü„ÉªÁµÇ‰∫Ü
								</Button>
							) : (
								<Button
									rightIcon={<FaArrowRight />}
									onClick={handleNext}
									colorScheme="purple"
									size="lg"
								>
									Ê¨°„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó
								</Button>
							)}
						</HStack>
					</Container>
				)}
			</Box>
		</Box>
	);
}
